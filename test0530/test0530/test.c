
//6.编写代码，以给定值x为基准将链表分割成两部分，所有小于x的结点排在大于或等于x的结点之前

//给定一个链表的头指针 ListNode* pHead，请返回重新排列后的链表的头指针。
//注意：分割以后保持原来的数据顺序不变。
/*
struct ListNode {
int val;
struct ListNode *next;
ListNode(int x) : val(x), next(NULL) {}
};*/
class Partition 
{
public:
	ListNode* partition(ListNode* pHead, int x) 
	{
		// write code here
	}
};



//7.链表的回文结构

/*
struct ListNode {
int val;
struct ListNode *next;
ListNode(int x) : val(x), next(NULL) {}
};*/
class PalindromeList 
{
public:
	bool chkPalindrome(ListNode* A) 
	{
		// write code here
	}
};



//8. 输入两个链表，找出它们的第一个公共结点

/**
* Definition for singly-linked list.
* struct ListNode {
*     int val;
*     struct ListNode *next;
* };
*/
struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) 
{

}





//9. 给定一个链表，判断链表中是否有环

/**
* Definition for singly-linked list.
* struct ListNode {
*     int val;
*     struct ListNode *next;
* };
*/
bool hasCycle(struct ListNode *head) 
{

}